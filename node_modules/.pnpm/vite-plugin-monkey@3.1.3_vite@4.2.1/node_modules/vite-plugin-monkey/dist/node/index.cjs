"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/node/index.ts
var node_exports = {};
__export(node_exports, {
  cdn: () => cdn_exports,
  default: () => node_default,
  util: () => util_exports
});
module.exports = __toCommonJS(node_exports);

// ../../node_modules/.pnpm/tsup@6.6.3_ts-node@10.9.1_typescript@4.9.5/node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl = () => typeof document === "undefined" ? new URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();

// src/node/cdn.ts
var cdn_exports = {};
__export(cdn_exports, {
  baomitu: () => baomitu,
  bdstatic: () => bdstatic,
  bootcdn: () => bootcdn,
  bytecdntp: () => bytecdntp,
  cdnjs: () => cdnjs,
  elemecdn: () => elemecdn,
  jsdelivr: () => jsdelivr,
  jsdelivrFastly: () => jsdelivrFastly,
  staticfile: () => staticfile,
  unpkg: () => unpkg,
  zhimg: () => zhimg
});
var jsdelivr = (exportVarName = "", pathname) => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      if (p) {
        return `https://cdn.jsdelivr.net/npm/${name}@${version}/${p}`;
      } else {
        return `https://cdn.jsdelivr.net/npm/${name}@${version}`;
      }
    }
  ];
};
var jsdelivrFastly = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      if (p) {
        return `https://fastly.jsdelivr.net/npm/${name}@${version}/${p}`;
      } else {
        return `https://fastly.jsdelivr.net/npm/${name}@${version}`;
      }
    }
  ];
};
var unpkg = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      if (p) {
        return `https://unpkg.com/${name}@${version}/${p}`;
      } else {
        return `https://unpkg.com/${name}@${version}`;
      }
    }
  ];
};
var bytecdntp = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://lf9-cdn-tos.bytecdntp.com/cdn/expire-10-y/${name}/${version}/${p}`;
    }
  ];
};
var bootcdn = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://cdn.bootcdn.net/ajax/libs/${name}/${version}/${p}`;
    }
  ];
};
var baomitu = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://lib.baomitu.com/${name}/${version}/${p}`;
    }
  ];
};
var staticfile = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://cdn.staticfile.org/${name}/${version}/${p}`;
    }
  ];
};
var cdnjs = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://cdnjs.cloudflare.com/ajax/libs/${name}/${version}/${p}`;
    }
  ];
};
var zhimg = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://unpkg.zhimg.com/${name}/${version}/${p}`;
    }
  ];
};
var elemecdn = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://npm.elemecdn.com/${name}@${version}/${p}`;
    }
  ];
};
var bdstatic = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://code.bdstatic.com/npm/${name}@${version}/${p}`;
    }
  ];
};

// src/node/_util.ts
var import_node_fs = require("fs");
var import_promises = __toESM(require("fs/promises"), 1);
var import_node_module = require("module");
var import_node_path = __toESM(require("path"), 1);
var import_vite = require("vite");

// src/node/_logger.ts
var import_picocolors = __toESM(require("picocolors"), 1);
var log = (tag, message, options) => {
  console.log(
    [
      ((options == null ? void 0 : options.time) ?? false) === true ? import_picocolors.default.dim((/* @__PURE__ */ new Date()).toLocaleTimeString()) : "",
      import_picocolors.default.bold(import_picocolors.default.blue(`[${tag}]`)),
      message
    ].filter((s) => s).join(" ")
  );
};
var info = (tag, message, options) => {
  log(tag, import_picocolors.default.white(message), options);
};
var warn = (tag, message, options) => {
  log(tag, import_picocolors.default.yellow(message), options);
};
var error = (tag, message, options) => {
  log(tag, import_picocolors.default.red(message), options);
};
var createLogger = (tag) => ({
  info: async (message, options) => {
    info(tag, message, options);
  },
  warn: async (message, options) => {
    warn(tag, message, options);
  },
  error: async (message, options) => {
    error(tag, message, options);
  }
});
var logger = createLogger("plugin-monkey");

// src/node/_util.ts
var get_vite_start_time = () => {
  const n = Reflect.get(globalThis, "__vite_start_time") ?? 0;
  if (typeof n != "number") {
    return 0;
  } else {
    return n;
  }
};
var isFirstBoot = (n = 1e3) => get_vite_start_time() < n;
var GM_keywords = [
  "GM.addElement",
  "GM.addStyle",
  "GM.deleteValue",
  "GM.getResourceUrl",
  "GM.getValue",
  "GM.info",
  "GM.listValues",
  "GM.notification",
  "GM.openInTab",
  "GM.registerMenuCommand",
  "GM.setClipboard",
  "GM.setValue",
  "GM.xmlHttpRequest",
  "GM.cookie",
  "GM_addElement",
  "GM_addStyle",
  "GM_addValueChangeListener",
  "GM_cookie",
  "GM_deleteValue",
  "GM_download",
  "GM_getResourceText",
  "GM_getResourceURL",
  "GM_getTab",
  "GM_getTabs",
  "GM_getValue",
  "GM_info",
  "GM_listValues",
  "GM_log",
  "GM_notification",
  "GM_openInTab",
  "GM_registerMenuCommand",
  "GM_removeValueChangeListener",
  "GM_saveTab",
  "GM_setClipboard",
  "GM_setValue",
  "GM_unregisterMenuCommand",
  "GM_xmlhttpRequest",
  "unsafeWindow",
  "window.close",
  "window.focus",
  "window.onurlchange"
];
var projectPkg = (() => {
  var _a, _b, _c, _d, _e;
  let rawTarget = {};
  try {
    rawTarget = JSON.parse(
      (0, import_node_fs.readFileSync)(import_node_path.default.resolve(process.cwd(), "package.json"), "utf-8")
    );
  } catch {
    rawTarget = {};
  }
  const target = {
    name: "monkey",
    version: "1.0.0"
  };
  Object.entries(rawTarget).forEach(([k, v]) => {
    if (typeof v == "string") {
      Reflect.set(target, k, v);
    }
  });
  if (rawTarget.author instanceof Object && typeof ((_a = rawTarget.author) == null ? void 0 : _a.name) == "string") {
    target.author = (_b = rawTarget.author) == null ? void 0 : _b.name;
  }
  if (rawTarget.bugs instanceof Object && typeof ((_c = rawTarget.bugs) == null ? void 0 : _c.url) == "string") {
    target.bugs = (_d = rawTarget.bugs) == null ? void 0 : _d.url;
  }
  if (rawTarget.repository instanceof Object && typeof ((_e = rawTarget.repository) == null ? void 0 : _e.url) == "string") {
    const { url } = rawTarget.repository;
    if (url.startsWith("http")) {
      target.repository = url;
    } else if (url.startsWith("git+http")) {
      target.repository = url.slice(4);
    }
  }
  return target;
})();
var compatResolve = (() => {
  const compatRequire = (0, import_node_module.createRequire)(process.cwd() + "/any_filename.js");
  return (id) => {
    return compatRequire.resolve(id);
  };
})();
var existFile = async (path5) => {
  try {
    return (await import_promises.default.stat(path5)).isFile();
  } catch {
    return false;
  }
};
var resolvePackageJsonFromPath = async (name) => {
  const p = (0, import_vite.normalizePath)(process.cwd()).split("/");
  for (let i = p.length; i > 0; i--) {
    const p2 = `${p.slice(0, i).join("/")}/node_modules/${name}/package.json`;
    if (await existFile(p2)) {
      return p2;
    }
  }
};
var getModuleRealInfo = async (importName) => {
  const importName2 = (0, import_vite.normalizePath)(importName.split("?")[0]);
  const resolveName = (0, import_vite.normalizePath)(compatResolve(importName2)).replace(
    /.*\/node_modules\/[^/]+\//,
    ""
  );
  let version = void 0;
  const nameList = importName2.split("/");
  let pkgName = importName2;
  while (nameList.length > 0) {
    pkgName = nameList.join("/");
    const filePath = await (async () => {
      const p = await resolvePackageJsonFromPath(pkgName);
      if (p) {
        return p;
      }
      try {
        return compatResolve(`${pkgName}/package.json`);
      } catch {
        return void 0;
      }
    })();
    if (filePath === void 0 || !await existFile(filePath)) {
      nameList.pop();
      continue;
    }
    const modulePack = JSON.parse(
      await import_promises.default.readFile(filePath, "utf-8")
    );
    version = modulePack.version;
    break;
  }
  if (version === void 0) {
    logger.warn(
      `not found module ${importName2} version, use ${importName2}@latest`
    );
    pkgName = importName2;
    version = "latest";
  }
  return { version, name: pkgName, resolveName };
};
var miniCode = async (code, type = "js") => {
  return (await (0, import_vite.transformWithEsbuild)(code, "any_name." + type, {
    minify: true,
    sourcemap: false,
    legalComments: "none"
  })).code.trimEnd();
};
var toValidURL = (url) => {
  if (typeof url != "string")
    return;
  try {
    return new URL(url);
  } catch {
  }
};
var ESBUILD_MODULES_TARGET = [
  "es2020",
  "edge88",
  "firefox78",
  "chrome87",
  "safari14"
];
var getFinalTarget = (target) => {
  if (target === "modules") {
    target = ESBUILD_MODULES_TARGET;
  }
  return target;
};
var moduleExportExpressionWrapper = (expression) => {
  let n = 0;
  let identifier = ``;
  while (expression.includes(identifier)) {
    identifier = `_${(n || ``).toString(16)}`;
    n++;
  }
  return `(()=>{const ${identifier}=${expression};('default' in ${identifier})||(${identifier}.default=${identifier});return ${identifier}})()`;
};

// src/node/option.ts
var resolvedOption = (pluginOption) => {
  const build2 = pluginOption.build ?? {};
  const { externalResource = {} } = build2;
  const externalResource2 = {};
  for (const [k, v] of Object.entries(externalResource)) {
    if (typeof v == "string") {
      externalResource2[k] = {
        resourceName: () => k,
        resourceUrl: () => v
      };
    } else if (typeof v == "function") {
      externalResource2[k] = {
        resourceName: () => k,
        resourceUrl: v
      };
    } else if (v instanceof Array) {
      let resourceUrl2;
      let resourceName2 = () => k;
      const [resourceName, resourceUrl] = v;
      if (typeof resourceName == "string") {
        resourceName2 = (pkg) => resourceName || pkg.importName;
      } else {
        resourceName2 = (pkg) => resourceName(pkg.version, pkg.name, pkg.importName, pkg.resolveName);
      }
      if (typeof resourceUrl == "string") {
        resourceUrl2 = () => resourceUrl;
      } else {
        resourceUrl2 = (pkg) => resourceUrl(pkg.version, pkg.name, pkg.importName, pkg.resolveName);
      }
      externalResource2[k] = {
        resourceName: resourceName2,
        resourceUrl: resourceUrl2
      };
    } else {
      const { resourceUrl, loader, nodeLoader, resourceName } = v;
      let resourceUrl2;
      let resourceName2 = () => k;
      let nodeLoader2 = void 0;
      if (typeof resourceUrl == "string") {
        resourceUrl2 = () => resourceUrl;
      } else {
        resourceUrl2 = resourceUrl;
      }
      if (typeof resourceName == "string") {
        resourceName2 = () => resourceName;
      } else if (typeof resourceName == "function") {
        resourceName2 = resourceName;
      }
      if (typeof nodeLoader == "function") {
        nodeLoader2 = nodeLoader;
      } else if (typeof nodeLoader == "string") {
        nodeLoader2 = () => nodeLoader;
      }
      externalResource2[k] = {
        resourceName: resourceName2,
        resourceUrl: resourceUrl2,
        loader,
        nodeLoader: nodeLoader2
      };
    }
  }
  const server = pluginOption.server ?? {};
  const { prefix } = server;
  let prefix2 = (s) => "server:" + s;
  if (typeof prefix == "function") {
    prefix2 = prefix;
  } else if (typeof prefix == "string") {
    prefix2 = () => prefix;
  } else if (prefix === false) {
    prefix2 = (name2) => name2;
  }
  const externalGlobals2 = (build2 == null ? void 0 : build2.externalGlobals) ?? {};
  const externalGlobals = [];
  if (externalGlobals2 instanceof Array) {
    externalGlobals2.forEach((s) => externalGlobals.push(s));
  } else {
    Object.entries(externalGlobals2).forEach((s) => externalGlobals.push(s));
  }
  let {
    name = {},
    description = {},
    "exclude-match": excludeMatch = [],
    match = [],
    exclude = [],
    include = [],
    antifeature = [],
    require: require2 = [],
    connect = [],
    grant = [],
    webRequest = [],
    $extra = []
  } = pluginOption.userscript ?? {};
  if (typeof name == "string") {
    name = { "": name };
  } else if (!("" in name)) {
    name = { "": projectPkg.name, ...name };
  }
  if (typeof description == "string") {
    description = {
      "": description
    };
  } else if (!("" in description) && projectPkg.description) {
    description = { "": projectPkg.description, ...description };
  }
  if (!(excludeMatch instanceof Array)) {
    excludeMatch = [excludeMatch];
  }
  if (!(match instanceof Array)) {
    match = [match];
  }
  if (!(exclude instanceof Array)) {
    exclude = [exclude];
  }
  if (!(include instanceof Array)) {
    include = [include];
  }
  if (!(antifeature instanceof Array)) {
    antifeature = [antifeature];
  }
  if (!(require2 instanceof Array)) {
    require2 = [require2];
  }
  if (!(connect instanceof Array)) {
    connect = [connect];
  }
  if (!(webRequest instanceof Array)) {
    webRequest = [webRequest];
  }
  const grantSet = /* @__PURE__ */ new Set();
  if (typeof grant == "string") {
    grantSet.add(grant);
  } else if (grant instanceof Array) {
    grant.forEach((s) => grantSet.add(s));
  }
  const extra = [];
  ($extra instanceof Array ? $extra : Object.entries($extra)).forEach(
    ([k, v]) => {
      extra.push([k, ...v instanceof Array ? v : [v]]);
    }
  );
  const {
    icon64,
    icon64URL,
    icon,
    iconURL,
    namespace = `vite-plugin-monkey`,
    version = projectPkg.version,
    author = projectPkg.author ?? "monkey",
    copyright,
    downloadURL,
    defaulticon,
    contributionURL,
    updateURL,
    supportURL = projectPkg.bugs,
    homepageURL = projectPkg.homepage,
    homepage = projectPkg.homepage,
    website,
    license = projectPkg.license,
    incompatible,
    source = projectPkg.repository,
    resource = {},
    noframes = false,
    "run-at": runAt,
    "inject-into": injectInto,
    contributionAmount,
    compatible,
    sandbox,
    unwrap = false
  } = pluginOption.userscript ?? {};
  const { fileName = projectPkg.name + ".user.js" } = build2;
  let { metaFileName } = build2;
  if (typeof metaFileName == "string") {
    const t = metaFileName;
    metaFileName = () => t;
  } else if (metaFileName === true) {
    metaFileName = () => fileName.replace(/\.user\.js$/, ".meta.js");
  } else if (metaFileName === false) {
    metaFileName = void 0;
  }
  const config = {
    userscript: {
      name,
      namespace,
      version,
      icon64,
      icon64URL,
      icon,
      iconURL,
      author,
      copyright,
      downloadURL,
      defaulticon,
      contributionURL,
      updateURL,
      supportURL,
      homepageURL,
      homepage,
      website,
      license,
      incompatible,
      source,
      resource,
      noframes,
      "run-at": runAt,
      "inject-into": injectInto,
      contributionAmount,
      compatible,
      "exclude-match": excludeMatch.map((s) => String(s)),
      match: match.map((s) => String(s)),
      include: include.map((s) => String(s)),
      exclude: exclude.map((s) => String(s)),
      antifeature,
      require: require2,
      connect,
      description,
      $extra: extra,
      grant: grantSet,
      sandbox,
      unwrap,
      webRequest: webRequest.map((w) => JSON.stringify(w))
    },
    clientAlias: pluginOption.clientAlias ?? "$",
    entry: pluginOption.entry,
    format: pluginOption.format,
    server: {
      mountGmApi: server.mountGmApi ?? false,
      open: server.open ?? (process.platform == "win32" || process.platform == "darwin"),
      prefix: prefix2
    },
    build: {
      fileName,
      metaFileName,
      autoGrant: build2.autoGrant ?? true,
      minifyCss: build2.minifyCss ?? true,
      externalGlobals,
      externalResource: externalResource2
    },
    collectGrantSet: /* @__PURE__ */ new Set(),
    collectRequireUrls: [],
    collectResource: {},
    hasDynamicImport: false,
    injectCssCode: ``,
    globalsPkg2VarName: {},
    requirePkgList: [],
    systemjs: build2.systemjs ?? jsdelivr()[1]
  };
  return config;
};

// src/node/inject_template.ts
var fn2string = (fn, ...args) => {
  return `;(${fn})(...${JSON.stringify(args, void 0, 2)});`;
};
var serverInjectFn = ({ entrySrc = `` }) => {
  window.GM;
  document.__monkeyWindow = window;
  console.log(`[vite-plugin-monkey] mount monkeyWindow to document`);
  const entryScript = document.createElement("script");
  entryScript.type = "module";
  entryScript.src = entrySrc;
  document.head.insertBefore(entryScript, document.head.firstChild);
  console.log(`[vite-plugin-monkey] mount entry module to document.head`);
};
var cssInjectFn = (css) => {
  const style = document.createElement("style");
  style.dataset.source = "vite-plugin-monkey";
  style.textContent = css;
  document.head.append(style);
};
var mountGmApiFn = () => {
  const monkeyWindow = document.__monkeyWindow;
  if (!monkeyWindow) {
    console.log(`[vite-plugin-monkey] not found monkeyWindow`);
    return;
  }
  window.unsafeWindow = window;
  console.log(`[vite-plugin-monkey] mount unsafeWindow to unsafeWindow`);
  const mountedApiList = [];
  Object.entries(monkeyWindow).filter(([k]) => k.startsWith("GM")).forEach(([k, fn]) => {
    window[k] = fn;
    mountedApiList.push(k);
  });
  console.log(
    `[vite-plugin-monkey] mount ${mountedApiList.length} GM_api to unsafeWindow`
  );
};
var redirectFn = async (url) => {
  const delay = async (n = 0) => {
    await new Promise((res) => {
      setTimeout(res, n);
    });
  };
  await delay();
  const u = new URL(url, location.origin);
  u.searchParams.set("origin", u.origin);
  if (window == window.parent) {
    location.href = u.href;
    await delay(500);
    window.close();
    return;
  }
  const style = document.createElement("style");
  document.body.append(style);
  style.innerText = /* css */
  `
.App {
  margin-top: 20vh;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.App > a {
  font-size: 32px;
  text-align: center;
}
.App > .copy {
  margin-top: 20px;
  padding: 4px;
  font-size: 15px;
  border: 2px solid;
  cursor: pointer;
  user-select: none;
}
.App > .copied {
  opacity: 0;
  margin-top: 10px;
  font-size: 12px;
  padding: 8px;
  border-radius: 5px;
  background-color: black;
  color: white;
}
.App > .copy:active + .copied {
  opacity: 1;
}
.App > .copy:not(:active) + .copied {
  transition: opacity 750ms;
}
`.trim();
  const div = document.createElement("div");
  document.body.append(div);
  div.innerHTML = /* html */
  `
<div class="App">
  <a target="_blank"></a>
  <div class="copy">COPY</div>
  <div class="copied">Copied!</div>
</div>
  `.trim();
  await delay();
  const a = div.querySelector("a");
  a.href = location.href;
  a.text = location.href;
  const copy = document.querySelector(".copy");
  copy.addEventListener("click", async () => {
    await navigator.clipboard.writeText(u.href);
  });
};

// src/node/plugins/server.ts
var import_detect_port = __toESM(require("detect-port"), 1);
var import_htmlparser2 = require("htmlparser2");
var import_promises2 = __toESM(require("fs/promises"), 1);
var import_node_path3 = __toESM(require("path"), 1);
var import_vite2 = require("vite");

// src/node/open_browser.ts
var import_cross_spawn = __toESM(require("cross-spawn"), 1);
var import_node_child_process = require("child_process");
var import_node_path2 = __toESM(require("path"), 1);
var import_open = __toESM(require("open"), 1);
var import_picocolors2 = __toESM(require("picocolors"), 1);
var OSX_CHROME = "google chrome";
function openBrowser(url, opt, logger2) {
  const browser = typeof opt === "string" ? opt : process.env.BROWSER || "";
  if (browser.toLowerCase().endsWith(".js")) {
    return executeNodeScript(browser, url, logger2);
  } else if (browser.toLowerCase() !== "none") {
    return startBrowserProcess(browser, url);
  }
  return false;
}
function executeNodeScript(scriptPath, url, logger2) {
  const extraArgs = process.argv.slice(2);
  const child = (0, import_cross_spawn.default)(process.execPath, [scriptPath, ...extraArgs, url], {
    stdio: "inherit"
  });
  child.on("close", (code) => {
    if (code !== 0) {
      logger2.error(
        import_picocolors2.default.red(
          `
The script specified as BROWSER environment variable failed.

${import_picocolors2.default.cyan(
            scriptPath
          )} exited with code ${code}.`
        ),
        { time: true }
      );
    }
  });
  return true;
}
function startBrowserProcess(browser, url) {
  const shouldTryOpenChromeWithAppleScript = process.platform === "darwin" && (browser === "" || browser === OSX_CHROME);
  if (shouldTryOpenChromeWithAppleScript) {
    try {
      (0, import_node_child_process.execSync)('ps cax | grep "Google Chrome"');
      (0, import_node_child_process.execSync)('osascript openChrome.applescript "' + encodeURI(url) + '"', {
        cwd: import_node_path2.default.dirname(compatResolve("vite/bin/openChrome.applescript")),
        stdio: "ignore"
      });
      return true;
    } catch (err) {
    }
  }
  if (process.platform === "darwin" && browser === "open") {
    browser = void 0;
  }
  try {
    const options = browser ? { app: { name: browser } } : {};
    (0, import_open.default)(url, options).catch(() => {
    });
    return true;
  } catch (err) {
    return false;
  }
}

// src/node/userscript/greasemonkey.ts
var GreaseGrantValueList = [
  "GM.info",
  "GM.deleteValue",
  "GM.getValue",
  "GM.listValues",
  "GM.setValue",
  "GM.getResourceUrl",
  "GM.notification",
  "GM.openInTab",
  "GM.registerMenuCommand",
  "GM.setClipboard",
  "GM.xmlHttpRequest",
  "unsafeWindow"
];

// src/node/userscript/tampermonkey.ts
var TamperGrantValueList = [
  "unsafeWindow",
  "window.close",
  "window.focus",
  "window.onurlchange",
  "GM_addStyle",
  "GM_addElement",
  "GM_deleteValue",
  "GM_listValues",
  "GM_addValueChangeListener",
  "GM_removeValueChangeListener",
  "GM_setValue",
  "GM_getValue",
  "GM_log",
  "GM_getResourceText",
  "GM_getResourceURL",
  "GM_registerMenuCommand",
  "GM_unregisterMenuCommand",
  "GM_openInTab",
  "GM_xmlhttpRequest",
  "GM_download",
  "GM_getTab",
  "GM_saveTab",
  "GM_getTabs",
  "GM_notification",
  "GM_setClipboard",
  "GM_info",
  "GM_cookie",
  "GM_webRequest"
];

// src/node/userscript/violentmonkey.ts
var ViolentGrantValueList = [
  "window.close",
  "window.focus",
  "GM_info",
  "GM_getValue",
  "GM_setValue",
  "GM_deleteValue",
  "GM_listValues",
  "GM_addValueChangeListener",
  "GM_removeValueChangeListener",
  "GM_getResourceText",
  "GM_getResourceURL",
  "GM_addElement",
  "GM_addStyle",
  "GM_openInTab",
  "GM_registerMenuCommand",
  "GM_unregisterMenuCommand",
  "GM_notification",
  "GM_setClipboard",
  "GM_xmlhttpRequest",
  "GM_download",
  "GM.addStyle",
  "GM.addElement",
  "GM.registerMenuCommand",
  "GM.deleteValue",
  "GM.getResourceUrl",
  "GM.getValue",
  "GM.info",
  "GM.listValues",
  "GM.notification",
  "GM.openInTab",
  "GM.setClipboard",
  "GM.setValue",
  "GM.xmlHttpRequest"
];

// src/node/userscript/index.ts
var finalMonkeyOptionToComment = async ({
  userscript,
  format = { align: 2 },
  collectGrantSet,
  collectRequireUrls,
  collectResource
}) => {
  let attrList = [];
  const {
    name,
    namespace,
    version,
    author,
    description,
    license,
    copyright,
    icon,
    iconURL,
    icon64,
    icon64URL,
    defaulticon,
    homepage,
    homepageURL,
    website,
    source,
    supportURL,
    downloadURL,
    updateURL,
    include,
    match,
    exclude,
    require: require2,
    "exclude-match": excludeMatch,
    "inject-into": injectInto,
    "run-at": runAt,
    compatible,
    incompatible,
    antifeature,
    contributionAmount,
    contributionURL,
    connect,
    sandbox,
    resource,
    grant,
    noframes,
    unwrap,
    webRequest,
    $extra
  } = userscript;
  Object.entries({
    namespace,
    version,
    author,
    license,
    copyright,
    icon,
    iconURL,
    icon64,
    icon64URL,
    defaulticon,
    homepage,
    homepageURL,
    website,
    source,
    supportURL,
    downloadURL,
    updateURL,
    "inject-into": injectInto,
    "run-at": runAt,
    compatible,
    incompatible,
    contributionAmount,
    contributionURL,
    sandbox
  }).forEach(([k, v]) => {
    if (typeof v == "string") {
      attrList.push([k, v]);
    }
  });
  Object.entries(name).forEach(([k, v]) => {
    if (k == "") {
      attrList.push(["name", v]);
    } else {
      attrList.push(["name:" + k, v]);
    }
  });
  Object.entries(description).forEach(([k, v]) => {
    if (k == "") {
      attrList.push(["description", v]);
    } else {
      attrList.push(["description:" + k, v]);
    }
  });
  Object.entries({
    include,
    match,
    exclude,
    "exclude-match": excludeMatch
  }).forEach(([k, v]) => {
    v.forEach((v2) => {
      attrList.push([k, v2]);
    });
  });
  [...require2, ...collectRequireUrls].forEach((s) => {
    attrList.push(["require", s]);
  });
  Object.entries({ ...resource, ...collectResource }).forEach(([k, v]) => {
    attrList.push(["resource", k, v]);
  });
  connect.forEach((s) => {
    attrList.push(["connect", s]);
  });
  webRequest.forEach((s) => {
    attrList.push(["webRequest", s]);
  });
  if (grant.has("none")) {
    attrList.push(["grant", "none"]);
  } else if (grant.has("*")) {
    (/* @__PURE__ */ new Set([
      ...GreaseGrantValueList,
      ...ViolentGrantValueList,
      ...TamperGrantValueList
    ])).forEach((s) => {
      attrList.push(["grant", s]);
    });
  } else {
    (/* @__PURE__ */ new Set([...Array.from(collectGrantSet.values()).flat(), ...grant])).forEach(
      (s) => {
        attrList.push(["grant", s]);
      }
    );
  }
  antifeature.forEach(({ description: description2, type, tag }) => {
    attrList.push([
      tag ? `antifeature:${tag}` : "antifeature",
      type,
      description2
    ]);
  });
  if (noframes) {
    attrList.push(["noframes"]);
  }
  if (unwrap) {
    attrList.push(["unwrap"]);
  }
  attrList.push(...$extra);
  attrList = defaultSortFormat(attrList);
  let { align = 2 } = format;
  if (align === true) {
    align = 2;
  }
  if (typeof align == "number" && Number.isInteger(align) && align >= 1) {
    const alignN = align;
    const formatKey = (subAttrList) => {
      if (subAttrList.length == 0)
        return;
      const maxLen2 = Math.max(...subAttrList.map((s) => s[1].length));
      subAttrList.forEach((s) => {
        s[1] = s[1].padEnd(alignN + maxLen2);
      });
    };
    formatKey(attrList.filter((s) => s[0] == "resource"));
    formatKey(
      attrList.filter(
        (s) => s[0] == "antifeature" || s[0].startsWith("antifeature:")
      )
    );
    const maxLen = Math.max(...attrList.map((s) => s[0].length));
    attrList.forEach((s) => {
      s[0] = s[0].padEnd(alignN + maxLen);
    });
  } else if (typeof align == "function") {
    attrList = await align(attrList);
  }
  return [
    "==UserScript==",
    ...attrList.map(
      (attr) => "@" + attr.map((v) => {
        return v.endsWith(" ") ? v : v + " ";
      }).join("").trimEnd()
    ),
    "==/UserScript=="
  ].map((s) => "// " + s).join("\n");
};
var stringSort = (a, b) => {
  const minLen = Math.min(a.length, b.length);
  for (let i = 0; i < minLen; i++) {
    if (a[i] > b[i]) {
      return 1;
    } else if (a[i] < b[i]) {
      return -1;
    }
  }
  if (a.length > b.length) {
    return 1;
  } else if (a.length < b.length) {
    return -1;
  }
  return 0;
};
var defaultSortFormat = (p0) => {
  const filter = (predicate) => {
    const notMatchList = [];
    const matchList = [];
    p0.forEach((value, index) => {
      if (!predicate(value, index)) {
        notMatchList.push(value);
      } else {
        matchList.push(value);
      }
    });
    p0 = notMatchList;
    return matchList;
  };
  return [
    filter(([k]) => k == "name"),
    filter(([k]) => k.startsWith("name:")),
    filter(([k]) => k == "namespace"),
    filter(([k]) => k == "version"),
    filter(([k]) => k == "author"),
    filter(([k]) => k == "description"),
    filter(([k]) => k.startsWith("description:")),
    filter(([k]) => k == "license"),
    filter(([k]) => k == "copyright"),
    filter(([k]) => k == "icon"),
    filter(([k]) => k == "iconURL"),
    filter(([k]) => k == "icon64"),
    filter(([k]) => k == "icon64URL"),
    filter(([k]) => k == "defaulticon"),
    filter(([k]) => k == "homepage"),
    filter(([k]) => k == "homepageURL"),
    filter(([k]) => k == "website"),
    filter(([k]) => k == "source"),
    filter(([k]) => k == "supportURL"),
    filter(([k]) => k == "downloadURL"),
    filter(([k]) => k == "updateURL"),
    filter(([k]) => k == "include"),
    filter(([k]) => k == "match"),
    filter(([k]) => k == "exclude"),
    filter(([k]) => k == "exclude-match"),
    filter(([k]) => k == "webRequest"),
    filter(([k]) => k == "require"),
    filter(([k]) => k == "resource").sort(stringSort),
    filter(([k]) => k == "sandbox"),
    filter(([k]) => k == "connect"),
    filter(([k]) => k == "grant").sort(stringSort),
    filter(([k]) => k == "inject-into"),
    filter(([k]) => k == "run-at"),
    filter(([k]) => k == "compatible"),
    filter(([k]) => k == "incompatible"),
    filter(([k]) => k == "antifeature").sort(stringSort),
    filter(([k]) => k.startsWith("antifeature:")).sort(stringSort),
    filter(([k]) => k == "contributionAmount"),
    filter(([k]) => k == "contributionURL"),
    filter(([k]) => k == "noframes"),
    filter(([k]) => k == "unwrap"),
    p0
  ].flat(1);
};

// src/node/_lazy.ts
var lazyValuePlaceholder = {};
var lazy = (fn) => {
  let temp = void 0;
  let o = {
    get k() {
      if (temp === void 0) {
        temp = fn();
      }
      return temp;
    }
  };
  const wm = lazyValue(() => /* @__PURE__ */ new WeakMap());
  return new Proxy(lazyValuePlaceholder, {
    get(_, p, receiver) {
      const v = Reflect.get(o.k, p, receiver);
      if (typeof v == "function") {
        const f = v;
        let fBind = wm.value.get(f);
        if (fBind === void 0) {
          fBind = f.bind(o.k);
          wm.value.set(f, fBind);
        }
        return fBind;
      }
      return v;
    },
    set(_, p, newValue, receiver) {
      return Reflect.set(o.k, p, newValue, receiver);
    },
    has(_, p) {
      return Reflect.has(o.k, p);
    },
    ownKeys() {
      return Reflect.ownKeys(o.k);
    },
    isExtensible() {
      return Reflect.isExtensible(o.k);
    },
    deleteProperty(_, p) {
      return Reflect.deleteProperty(o.k, p);
    },
    setPrototypeOf(_, v) {
      return Reflect.setPrototypeOf(o.k, v);
    },
    getOwnPropertyDescriptor(_, p) {
      return Reflect.getOwnPropertyDescriptor(o.k, p);
    },
    defineProperty(_, property, attributes) {
      return Reflect.defineProperty(o.k, property, attributes);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(o.k);
    },
    preventExtensions() {
      return Reflect.preventExtensions(o.k);
    },
    apply(_, thisArg, argArray) {
      return Reflect.apply(o.k, thisArg, argArray);
    },
    construct(_, argArray, newTarget) {
      return Reflect.construct(o.k, argArray, newTarget);
    }
  });
};
var lazyValue = (fn) => {
  let temp = lazyValuePlaceholder;
  return {
    get value() {
      if (temp === lazyValuePlaceholder) {
        temp = fn();
      }
      return temp;
    }
  };
};

// src/node/plugins/server.ts
var installUserPath = "/__vite-plugin-monkey.install.user.js";
var gmApiPath = "/__vite-plugin-monkey.gm.api.js";
var entryPath = "/__vite-plugin-monkey.entry.js";
var pullPath = "/__vite-plugin-monkey.pull.js";
var cacheUserPath = "node_modules/.vite/__vite-plugin-monkey.cache.user.js";
var serverPlugin = (finalOption) => {
  let viteConfig;
  const serverConfig = lazy(() => {
    let availablePort = 5173;
    (0, import_detect_port.default)(availablePort).then((p) => {
      availablePort = p;
    });
    return {
      get isHttps() {
        return !!viteConfig.server.https;
      },
      get port() {
        return viteConfig.server.port ?? availablePort;
      },
      get host() {
        if (typeof viteConfig.server.host == "string" && viteConfig.server.host != "0.0.0.0") {
          return viteConfig.server.host;
        }
        return "127.0.0.1";
      },
      get defaultOrigin() {
        return `${this.isHttps ? "https" : "http"}://${this.host}:${this.port}`;
      },
      get installUrl() {
        return new URL(viteConfig.base, this.defaultOrigin).href;
      }
    };
  });
  return {
    name: "monkey:server",
    apply: "serve",
    async config(userConfig) {
      var _a, _b;
      return {
        preview: {
          host: ((_a = userConfig.preview) == null ? void 0 : _a.host) ?? "127.0.0.1",
          cors: true
        },
        server: {
          open: ((_b = userConfig.server) == null ? void 0 : _b.open) ?? finalOption.server.open,
          cors: true
        }
      };
    },
    async configResolved(resolvedConfig) {
      viteConfig = resolvedConfig;
      const { server } = viteConfig;
      server.host = serverConfig.host;
      server.port = serverConfig.port;
      const baseConfig = {
        host: serverConfig.host,
        protocol: serverConfig.isHttps ? "wss" : "ws"
      };
      if (server.hmr === void 0 && server.hmr === true) {
        server.hmr = baseConfig;
      } else if (server.hmr && typeof server.hmr == "object") {
        Object.assign(server.hmr, baseConfig);
      }
    },
    async configureServer(server) {
      for (const [k, v] of Object.entries(finalOption.userscript.name)) {
        Reflect.set(
          finalOption.userscript.name,
          k,
          finalOption.server.prefix(v)
        );
      }
      finalOption.userscript.grant.add("*");
      server.middlewares.use(async (req, res, next) => {
        var _a;
        let viteHost = req.headers[":authority"] ?? req.headers["host"] ?? [];
        if (viteHost instanceof Array) {
          viteHost = viteHost[0];
        }
        if (!viteHost) {
          logger.error("host not found", { time: true });
          return next();
        }
        const viteOrigin = `${serverConfig.isHttps ? "https" : "http"}://${viteHost}`;
        const reqUrl = req.url;
        if (reqUrl && [installUserPath, entryPath, pullPath, gmApiPath].some(
          (u) => reqUrl.startsWith(u)
        )) {
          Object.entries({
            "access-control-allow-origin": "*",
            "content-type": "application/javascript"
          }).forEach(([k, v]) => {
            res.setHeader(k, v);
          });
          const usp = new URLSearchParams(reqUrl.split("?", 2)[1]);
          let origin = ((_a = toValidURL(usp.get(`origin`))) == null ? void 0 : _a.origin) ?? viteOrigin;
          if (reqUrl.startsWith(installUserPath)) {
            const u = new URL(entryPath, origin);
            res.end(
              [
                await finalMonkeyOptionToComment(finalOption),
                fn2string(serverInjectFn, {
                  entrySrc: u.href
                }),
                ""
              ].join("\n\n")
            );
          } else if (reqUrl.startsWith(entryPath)) {
            const htmlText2 = await server.transformIndexHtml(
              "/",
              `<html><head></head></html>`,
              req.originalUrl
            );
            const doc = (0, import_htmlparser2.parseDocument)(htmlText2);
            const scriptList = import_htmlparser2.DomUtils.getElementsByTagType(
              import_htmlparser2.ElementType.Script,
              doc
            );
            const entryList = finalOption.server.mountGmApi ? [gmApiPath] : [];
            scriptList.forEach((p) => {
              const src = p.attribs.src ?? "";
              const textNode = p.firstChild;
              let text = "";
              if ((textNode == null ? void 0 : textNode.type) == import_htmlparser2.ElementType.Text) {
                text = textNode.data ?? "";
              }
              if (src) {
                entryList.push(src);
              } else {
                const scriptUrl = new URL(origin);
                scriptUrl.pathname = pullPath;
                scriptUrl.searchParams.set(
                  "text",
                  Buffer.from(text, "utf-8").toString("base64url")
                );
                entryList.push(scriptUrl.pathname + scriptUrl.search);
              }
            });
            let realEntry = finalOption.entry;
            if (import_node_path3.default.isAbsolute(realEntry)) {
              realEntry = (0, import_vite2.normalizePath)(
                import_node_path3.default.relative(viteConfig.root, realEntry)
              );
            }
            const entryUrl = new URL(realEntry, origin);
            entryList.push(entryUrl.pathname + entryUrl.search);
            res.end(
              entryList.map((s) => `import ${JSON.stringify(s)};`).join("\n")
            );
          } else if (reqUrl.startsWith(pullPath)) {
            res.end(
              Buffer.from(usp.get("text") ?? "", "base64url").toString("utf-8")
            );
          } else if (reqUrl.startsWith(gmApiPath)) {
            if (finalOption.server.mountGmApi) {
              res.end(fn2string(mountGmApiFn));
            } else {
              res.end("");
            }
          }
          return;
        }
        next();
      });
      if (finalOption.server.open) {
        let cacheComment = "";
        if (await existFile(cacheUserPath)) {
          cacheComment = (await import_promises2.default.readFile(cacheUserPath)).toString("utf-8");
        } else {
          await import_promises2.default.mkdir(import_node_path3.default.dirname(cacheUserPath)).catch();
        }
        const newComment = [
          await finalMonkeyOptionToComment(finalOption),
          `// entry: ${finalOption.entry}`
        ].join("\n");
        if (!isFirstBoot() && cacheComment != newComment) {
          openBrowser(serverConfig.installUrl, true, logger);
          logger.info("reopen, config comment has changed", { time: true });
        }
        await import_promises2.default.writeFile(cacheUserPath, newComment).catch();
      }
    }
  };
};

// src/node/plugins/virtualHtml.ts
var htmlText = `
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="https://vitejs.dev/logo.svg" />
    <title>Vite</title>
  </head>
  <script type="module" data-source="vite-plugin-monkey">
  ${fn2string(redirectFn, installUserPath).trim()}
  </script>
</html>
`.trimStart();
var virtualHtmlPlugin = (finalOption) => {
  return {
    name: "monkey:virtualHtml",
    apply: "serve",
    configureServer(server) {
      server.middlewares.use(async (req, res, next) => {
        const url = req.url || "/";
        if (["/", "/index.html"].includes(url)) {
          res.setHeader("content-type", "text/html");
          res.setHeader("cache-control", "no-cache");
          res.setHeader("access-control-allow-origin", "*");
          return res.end(htmlText);
        }
        next();
      });
    }
  };
};

// src/node/plugins/fixViteAsset.ts
var template = `
export default ((()=>{
  try{
    return new URL(__VALUE__, import.meta['url']).href
  }catch(_){
    return __VALUE__
  }
})())
`.trimStart();
var fixViteAssetPlugin = (finalOption) => {
  let viteConfig;
  return {
    name: "monkey:fixViteAsset",
    apply: "serve",
    async configResolved(resolvedConfig) {
      viteConfig = resolvedConfig;
    },
    async transform(code, id) {
      var _a;
      const [_, query = "url"] = id.split("?", 2);
      if ((query.split("&").includes("url") || viteConfig.assetsInclude(id)) && code.match(/^\s*export\s+default/)) {
        const ast = this.parse(code);
        if (ast.type == "Program") {
          const defaultNode = (_a = ast.body) == null ? void 0 : _a[0];
          if ((defaultNode == null ? void 0 : defaultNode.type) == "ExportDefaultDeclaration") {
            const declarationNode = defaultNode == null ? void 0 : defaultNode.declaration;
            const value = declarationNode == null ? void 0 : declarationNode.value;
            if ((declarationNode == null ? void 0 : declarationNode.type) == "Literal" && typeof value == "string") {
              return template.replace(/__VALUE__/g, JSON.stringify(value));
            }
          }
        }
      }
    }
  };
};

// src/node/plugins/fixViteClient.ts
var fixViteClientPlugin = (finalOption) => {
  return {
    name: "monkey:fixViteClient",
    apply: "serve",
    async transform(code, id) {
      if (id.endsWith("node_modules/vite/dist/client/client.mjs")) {
        code = code.replace(
          /__HMR_PROTOCOL__/g,
          `(__HMR_PROTOCOL__ || ((()=>{const u = new URL(import.meta['url'], location.origin);return u.protocol === 'https:' ? 'wss' : 'ws'})()))`
        );
        code = code.replace(
          /__BASE__/g,
          `((()=>{const b = __BASE__; const u = new URL(import.meta['url'], location.origin); return b !== '/' ? b : (u.origin+'/');})())`
        );
        code = code.replace(
          "`${location.protocol}//${hostAndPath}`",
          "`${new URL(import.meta['url'], location.origin).protocol}//${hostAndPath}`"
        );
        return code;
      }
    }
  };
};

// src/node/plugins/autoGrant.ts
var import_vite3 = require("vite");
var GM_keyword_set = Array.from(new Set(GM_keywords));
var autoGrantPlugin = (finalOption) => {
  const collectGrantMap = /* @__PURE__ */ new Map();
  return {
    name: "monkey:autoGrant",
    apply: "build",
    enforce: "post",
    async transform(code, id) {
      id = (0, import_vite3.normalizePath)(id);
      if (finalOption.build.autoGrant && !id.endsWith("vite-plugin-monkey/dist/client/index.mjs") && !id.endsWith("vite-plugin-monkey/dist/native/index.mjs") && !id.includes("virtual:plugin-monkey-loader")) {
        collectGrantMap.set(
          id,
          GM_keyword_set.filter((fnName) => code.includes(fnName))
        );
      }
    },
    generateBundle() {
      const idSet = new Set(
        Array.from(this.getModuleIds()).map((s) => (0, import_vite3.normalizePath)(s))
      );
      Array.from(collectGrantMap.keys()).forEach((s) => {
        if (!idSet.has(s)) {
          collectGrantMap.delete(s);
        }
      });
      finalOption.collectGrantSet = new Set(
        Array.from(collectGrantMap.values()).flat()
      );
    }
  };
};

// src/node/plugins/externalGlobals.ts
var import_vite4 = require("vite");
var externalGlobalsPlugin = (finalOption) => {
  const { globalsPkg2VarName, requirePkgList } = finalOption;
  return {
    name: "monkey:externalGlobals",
    enforce: "pre",
    apply: "build",
    async config() {
      for (const [moduleName, varName2LibUrl] of finalOption.build.externalGlobals) {
        const { name, version } = await getModuleRealInfo(moduleName);
        if (typeof varName2LibUrl == "string") {
          globalsPkg2VarName[moduleName] = varName2LibUrl;
        } else if (typeof varName2LibUrl == "function") {
          globalsPkg2VarName[moduleName] = await varName2LibUrl(
            version,
            name,
            moduleName
          );
        } else if (varName2LibUrl instanceof Array) {
          const [varName, ...libUrlList] = varName2LibUrl;
          if (typeof varName == "string") {
            globalsPkg2VarName[moduleName] = varName;
          } else if (typeof varName == "function") {
            globalsPkg2VarName[moduleName] = await varName(
              version,
              name,
              moduleName
            );
          }
          for (const libUrl of libUrlList) {
            if (typeof libUrl == "string") {
              requirePkgList.push({ url: libUrl, moduleName });
            } else if (typeof libUrl == "function") {
              requirePkgList.push({
                url: await libUrl(version, name, moduleName),
                moduleName
              });
            }
          }
        }
      }
      return {
        build: {
          rollupOptions: {
            external(source, _importer, _isResolved) {
              return source in globalsPkg2VarName;
            }
            // output: {
            //   globals: globalsPkg2VarName,
            //   inlineDynamicImports: true, // see https://rollupjs.org/guide/en/#outputinlinedynamicimports
            // },
          }
        }
      };
    },
    // async resolveDynamicImport(specifier, _importer) {
    //   if (typeof specifier == 'string' && specifier in globalsPkg2VarName) {
    //     return dynamicImportPrefix + specifier + '\0';
    //   }
    // },
    // async load(id) {
    //   if (id.startsWith(dynamicImportPrefix) && id.endsWith('\0')) {
    //     const rawId = id.slice(dynamicImportPrefix.length, id.length - 1);
    //     if (rawId in globalsPkg2VarName) {
    //       return `export {default} from '${rawId}';export * from '${rawId}';`;
    //     }
    //   }
    // },
    async generateBundle() {
      const usedModIdSet = new Set(
        Array.from(this.getModuleIds()).map((s) => (0, import_vite4.normalizePath)(s))
      );
      finalOption.collectRequireUrls = requirePkgList.filter((p) => usedModIdSet.has(p.moduleName)).map((p) => p.url);
    }
  };
};

// src/node/plugins/externalLoader.ts
var import_vite5 = require("vite");
var GM_getResourceText = (name) => document.title;
var GM_getResourceURL = (name, isBlobUrl) => document.title;
var cssLoader = (resourceName) => {
  const css = GM_getResourceText(resourceName);
  const style = document.createElement("style");
  style.innerText = css;
  document.head.append(style);
  return css;
};
var jsonLoader = (resourceName) => JSON.parse(GM_getResourceText(resourceName));
var urlLoader = (resourceName, mediaType) => GM_getResourceURL(resourceName, false).replace(
  /^data:application;base64,/,
  `data:${mediaType};base64,`
);
var rawLoader = (resourceName) => GM_getResourceText(resourceName);
var moduleSourceCode = [
  `export const cssLoader = ${cssLoader}`,
  `export const jsonLoader = ${jsonLoader}`,
  `export const urlLoader = ${urlLoader}`,
  `export const rawLoader = ${rawLoader}`
].join(";");
var externalLoaderPlugin = (finalOption) => {
  return {
    name: "monkey:externalLoader",
    enforce: "pre",
    apply: "build",
    async resolveId(id) {
      if (id == "virtual:plugin-monkey-loader") {
        return "\0" + id;
      }
    },
    async load(id) {
      if (id == "\0virtual:plugin-monkey-loader") {
        return (0, import_vite5.transformWithEsbuild)(
          moduleSourceCode,
          "/virtual/plugin-monkey-loader/index.js",
          {
            minify: true,
            sourcemap: true,
            legalComments: "none"
          }
        );
      }
    }
  };
};

// src/node/plugins/externalResource.ts
var import_vite6 = require("vite");
var import_mrmime = require("mrmime");
var import_node_url = require("url");
var resourceImportPrefix = "\0monkey-resource-import:";
var externalResourcePlugin = (finalOption) => {
  const resourceRecord = {};
  let viteConfig;
  return {
    name: "monkey:externalResource",
    enforce: "pre",
    apply: "build",
    configResolved(config) {
      viteConfig = config;
    },
    async resolveId(id) {
      const { externalResource } = finalOption.build;
      if (id in externalResource) {
        return resourceImportPrefix + id + "\0";
      }
      const [resource, query] = id.split("?", 2);
      if (resource.endsWith(".css") && query) {
        const id2 = [
          resource,
          "?",
          query.split("&").filter((e) => e != "used").join(`&`)
        ].join("");
        if (id2 in externalResource) {
          return resourceImportPrefix + id2 + "\0";
        }
      }
    },
    async load(id) {
      if (id.startsWith(resourceImportPrefix) && id.endsWith("\0")) {
        const { externalResource } = finalOption.build;
        const importName = id.substring(
          resourceImportPrefix.length,
          id.length - 1
        );
        if (!(importName in externalResource)) {
          return;
        }
        const pkg = await getModuleRealInfo(importName);
        const {
          resourceName: resourceNameFn,
          resourceUrl: resourceUrlFn,
          loader,
          nodeLoader
        } = externalResource[importName];
        const resourceName = await resourceNameFn({ ...pkg, importName });
        const resourceUrl = await resourceUrlFn({ ...pkg, importName });
        resourceRecord[importName] = {
          resourceName,
          resourceUrl
        };
        if (nodeLoader) {
          return miniCode(
            await nodeLoader({
              ...pkg,
              resourceName,
              resourceUrl,
              importName
            })
          );
        } else if (loader) {
          let fnText;
          if (loader.prototype && // not arrow function
          loader.name.length > 0 && loader.name != "function") {
            if (Reflect.get(loader, Symbol.toStringTag) == "AsyncFunction") {
              fnText = loader.toString().replace(/^[\s\S]+?\(/, "async function(");
            } else {
              fnText = loader.toString().replace(/^[\s\S]+?\(/, "function(");
            }
          } else {
            fnText = loader.toString();
          }
          return miniCode(
            `export default (${fnText})(${JSON.stringify({
              resourceUrl,
              importName,
              ...pkg
            })})`
          );
        }
        let moduleCode = void 0;
        const [resource, query] = importName.split("?", 2);
        const ext = resource.split(".").pop();
        const mimeType = (0, import_mrmime.lookup)(ext) ?? "application/octet-stream";
        const suffixSet = new import_node_url.URLSearchParams(query);
        if (suffixSet.has("url") || suffixSet.has("inline")) {
          moduleCode = [
            `import {urlLoader as loader} from 'virtual:plugin-monkey-loader'`,
            `export default loader(...${JSON.stringify([
              resourceName,
              mimeType
            ])})`
          ].join(";");
        } else if (suffixSet.has("raw")) {
          moduleCode = [
            `import {rawLoader as loader} from 'virtual:plugin-monkey-loader'`,
            `export default loader(...${JSON.stringify([resourceName])})`
          ].join(";");
        } else if (ext == "json") {
          moduleCode = [
            `import {jsonLoader as loader} from 'virtual:plugin-monkey-loader'`,
            `export default loader(...${JSON.stringify([resourceName])})`
          ].join(";");
        } else if (ext == "css") {
          moduleCode = [
            `import {cssLoader as loader} from 'virtual:plugin-monkey-loader'`,
            `export default loader(...${JSON.stringify([resourceName])})`
          ].join(";");
        } else if (viteConfig.assetsInclude(importName.split("?", 1)[0])) {
          const mediaType = import_mrmime.mimes[ext];
          moduleCode = [
            `import {urlLoader as loader} from 'virtual:plugin-monkey-loader'`,
            `export default loader(...${JSON.stringify([
              resourceName,
              mediaType
            ])})`
          ].join(";");
        }
        if (moduleCode) {
          if (moduleCode.includes("rawLoader") || moduleCode.includes("jsonLoader") || moduleCode.includes("cssLoader")) {
            finalOption.userscript.grant.add("GM_getResourceText");
          } else if (moduleCode.includes("urlLoader")) {
            finalOption.userscript.grant.add("GM_getResourceURL");
          }
          return miniCode(moduleCode);
        }
        throw new Error(`module: ${importName} not found loader`);
      }
    },
    generateBundle() {
      const usedModIdSet = new Set(
        Array.from(this.getModuleIds()).map((s) => (0, import_vite6.normalizePath)(s))
      );
      Array.from(usedModIdSet).forEach((id) => {
        if (id.startsWith(resourceImportPrefix) && id.endsWith("\0")) {
          usedModIdSet.add(
            id.substring(resourceImportPrefix.length, id.length - 1)
          );
        }
      });
      const collectResource = {};
      Object.entries(resourceRecord).forEach(
        ([importName, { resourceName, resourceUrl }]) => {
          if (usedModIdSet.has(importName)) {
            collectResource[resourceName] = resourceUrl;
          }
        }
      );
      finalOption.collectResource = collectResource;
    }
  };
};

// src/node/plugins/finalBundle.ts
var import_vite8 = require("vite");

// src/node/systemjs.ts
var import_node_module2 = __toESM(require("module"), 1);
var import_promises3 = __toESM(require("fs/promises"), 1);

// src/node/util.ts
var util_exports = {};
__export(util_exports, {
  dataUrl: () => dataUrl,
  fn2dataUrl: () => fn2dataUrl,
  unimportPreset: () => unimportPreset
});
var import_vite7 = require("vite");
var fn2dataUrl = async (fn, ...args) => {
  return "data:application/javascript," + encodeURIComponent(
    (await (0, import_vite7.transformWithEsbuild)(
      `;(${fn})(...${JSON.stringify(args)})`,
      "any_name.js",
      {
        minify: true,
        sourcemap: false,
        legalComments: "none"
      }
    )).code.trimEnd()
  );
};
function dataUrl(p0, ...args) {
  if (typeof p0 == "string") {
    return `data:application/javascript,` + encodeURIComponent(p0);
  }
  return fn2dataUrl(p0, ...args);
}
var unimportPreset = {
  from: "vite-plugin-monkey/dist/client",
  imports: [
    "GM",
    "GM_addElement",
    "GM_addStyle",
    "GM_addValueChangeListener",
    "GM_cookie",
    "GM_deleteValue",
    "GM_download",
    "GM_getResourceText",
    "GM_getResourceURL",
    "GM_getTab",
    "GM_getTabs",
    "GM_getValue",
    "GM_info",
    "GM_listValues",
    "GM_log",
    "GM_notification",
    "GM_openInTab",
    "GM_registerMenuCommand",
    "GM_removeValueChangeListener",
    "GM_saveTab",
    "GM_setClipboard",
    "GM_setValue",
    "GM_unregisterMenuCommand",
    "GM_xmlhttpRequest",
    "GM_webRequest",
    "unsafeWindow",
    "monkeyWindow"
  ]
};

// src/node/systemjs.ts
var _require = import_node_module2.default.createRequire(importMetaUrl);
var systemjsPkg = _require(`systemjs/package.json`);
var systemjsSubPaths = [
  "dist/system.min.js",
  "dist/extras/named-register.min.js"
];
var customSystemInstanceCode = `;(typeof System!='undefined')&&(System=new System.constructor());`;
var systemjsAbsolutePaths = systemjsSubPaths.map((s) => {
  return _require.resolve(`systemjs/` + s);
});
var systemjsTexts = lazyValue(() => {
  return Promise.all(
    systemjsAbsolutePaths.map(
      (s) => import_promises3.default.readFile(s, "utf-8").then(
        (s2) => s2.trim().replace(/^\/\*[\s\S]*?\*\//, "").replace(/\/\/.*map$/, "").trim()
      )
    ).concat([Promise.resolve(customSystemInstanceCode)])
  );
});
var getSystemjsRequireUrls = (fn) => {
  return systemjsSubPaths.map((p) => {
    return fn(systemjsPkg.version, systemjsPkg.name, p, p);
  }).concat([dataUrl(customSystemInstanceCode)]);
};

// src/node/topLevelAwait.ts
var acornWalk = __toESM(require("acorn-walk"), 1);
var import_magic_string = __toESM(require("magic-string"), 1);
var awaitOffset = `await`.length;
var tlaIdentifier = `__TOP_LEVEL_AWAIT__`;
var transformTlaToIdentifier = (context, chunk) => {
  if (chunk.type == "chunk") {
    const code = chunk.code;
    if (!code.includes(`await`)) {
      return;
    }
    const ast = context.parse(code);
    const tlaNodes = [];
    const tlaForOfNodes = [];
    acornWalk.simple(
      ast,
      {
        AwaitExpression(node) {
          tlaNodes.push(node);
        },
        // @ts-ignore
        ForOfStatement(node) {
          if (node.await === true) {
            tlaForOfNodes.push(node);
          }
        }
      },
      { ...acornWalk.base, Function: () => {
      } }
    );
    if (tlaNodes.length > 0 || tlaForOfNodes.length > 0) {
      const ms = new import_magic_string.default(code);
      tlaNodes.forEach((node) => {
        ms.appendLeft(node.start + awaitOffset, `(`);
        ms.appendRight(node.end, `)`);
        ms.update(node.start, node.start + awaitOffset, tlaIdentifier);
      });
      tlaForOfNodes.forEach((node) => {
        ms.appendLeft(node.start, `${tlaIdentifier}((async()=>{`);
        ms.appendRight(node.end, `})());`);
      });
      return {
        code: ms.toString(),
        map: ms.generateMap()
      };
    }
  }
};
var transformIdentifierToTla = (context, chunk) => {
  if (chunk.type == "chunk") {
    if (!chunk.code.includes(tlaIdentifier)) {
      return;
    }
    const base2 = Object.keys(acornWalk.base).reduce((p, key) => {
      if (key in p)
        return p;
      p[key] = (node, state, callback) => {
        if (chunk.code.substring(node.start, node.end).includes(tlaIdentifier)) {
          return acornWalk.base[key](node, state, callback);
        }
      };
      return p;
    }, {});
    const ast = context.parse(chunk.code);
    const tlaCallNodes = [];
    const topFnNodes = [];
    acornWalk.simple(
      ast,
      {
        // @ts-ignore
        CallExpression(node) {
          var _a, _b;
          if (((_a = node.callee) == null ? void 0 : _a.type) === `Identifier` && ((_b = node.callee) == null ? void 0 : _b.name) === tlaIdentifier) {
            tlaCallNodes.push(node);
          }
        }
      },
      {
        ...base2,
        Function: (node, state, callback) => {
          if (topFnNodes.length == 0) {
            topFnNodes.push(node);
          }
          if (chunk.code.substring(node.start, node.end).includes(tlaIdentifier)) {
            return acornWalk.base.Function(node, state, callback);
          }
        }
      }
    );
    if (tlaCallNodes.length > 0 || topFnNodes.length > 0) {
      const ms = new import_magic_string.default(chunk.code, {});
      tlaCallNodes.forEach((node) => {
        const callee = node.callee;
        const [argument] = node.arguments;
        ms.update(callee.start, callee.end, "");
        ms.update(callee.end, argument.start, `(await `);
      });
      topFnNodes.forEach((node) => {
        ms.appendLeft(node.start, `async `);
      });
      chunk.code = ms.toString();
      if (chunk.map) {
        chunk.map;
      }
    }
  }
};

// src/node/plugins/finalBundle.ts
var __entry_name = `__monkey.entry.js`;
var polyfillId = "\0vite/legacy-polyfills";
var systemJsImportMapPrefix = `user`;
var finalBundlePlugin = (finalOption) => {
  return {
    name: "monkey:finalBundle",
    apply: "build",
    enforce: "post",
    async generateBundle(_, rawBundle) {
      const entryChunks = (() => {
        const polyfillChunks = [];
        const chunks = [];
        Object.values(rawBundle).forEach((chunk) => {
          if (chunk.type == "chunk" && chunk.isEntry) {
            if (chunk.facadeModuleId == polyfillId) {
              polyfillChunks.push(chunk);
            } else {
              chunks.push(chunk);
            }
          }
        });
        return polyfillChunks.concat(chunks);
      })();
      finalOption.hasDynamicImport = entryChunks.some(
        (e) => e.dynamicImports.length > 0
      );
      const buildResult = await (0, import_vite8.build)({
        logLevel: "error",
        configFile: false,
        esbuild: false,
        plugins: [
          {
            name: "mokey:mock",
            enforce: "pre",
            resolveId(source, importer, options) {
              if (!importer && options.isEntry) {
                return "\0" + source;
              }
              const chunk = Object.values(rawBundle).find(
                (chunk2) => chunk2.type == "chunk" && source.endsWith(chunk2.fileName)
              );
              if (chunk) {
                return "\0" + source;
              }
            },
            async load(id) {
              if (!id.startsWith("\0"))
                return;
              if (id.endsWith(__entry_name)) {
                return entryChunks.map((a) => `import ${JSON.stringify(`./${a.fileName}`)};`).join("\n");
              }
              const [k, chunk] = Object.entries(rawBundle).find(
                ([k2, chunk2]) => id.endsWith(chunk2.fileName)
              ) ?? [];
              if (chunk && chunk.type == "chunk" && k) {
                delete rawBundle[k];
                if (!finalOption.hasDynamicImport) {
                  const ch = transformTlaToIdentifier(this, chunk);
                  if (ch)
                    return ch;
                }
                return {
                  code: chunk.code,
                  map: chunk.map
                };
              }
            },
            generateBundle(_2, iifeBundle) {
              if (finalOption.hasDynamicImport) {
                return;
              }
              Object.entries(iifeBundle).forEach(([k, chunk]) => {
                transformIdentifierToTla(this, chunk);
              });
            }
          }
        ],
        build: {
          write: false,
          minify: false,
          target: "esnext",
          rollupOptions: {
            external(source) {
              return source in finalOption.globalsPkg2VarName;
            },
            output: {
              globals: finalOption.globalsPkg2VarName
            }
          },
          lib: {
            entry: __entry_name,
            formats: [finalOption.hasDynamicImport ? "system" : "iife"],
            name: finalOption.hasDynamicImport ? void 0 : "__expose__",
            fileName: () => `__entry.js`
          }
        }
      });
      const finalBundle = Object.assign({}, rawBundle, buildResult[0].output);
      let finalJsCode = ``;
      if (finalOption.hasDynamicImport) {
        const systemJsModules = [];
        let entryName = "";
        Object.entries(finalBundle).forEach(([k, chunk]) => {
          if (chunk.type == "chunk") {
            const name = JSON.stringify(`./` + chunk.fileName);
            systemJsModules.push(
              chunk.code.trimStart().replace(/^System\.register\(/, `System.register(${name}, `)
            );
            if (chunk.isEntry) {
              entryName = name;
            }
          }
        });
        systemJsModules.push(`System.import(${entryName}, "./");`);
        finalJsCode = systemJsModules.join("\n");
        const usedModuleIds = Array.from(this.getModuleIds()).filter(
          (d) => d in finalOption.globalsPkg2VarName
        );
        const importsMap = usedModuleIds.reduce(
          (p, c) => {
            p[c] = `${systemJsImportMapPrefix}:${c}`;
            return p;
          },
          {}
        );
        finalJsCode = [
          Object.keys(importsMap).length > 0 ? `System.addImportMap({ imports: ${JSON.stringify(importsMap)} });` : ``,
          ...usedModuleIds.map(
            (id) => `System.set(${JSON.stringify(
              `${systemJsImportMapPrefix}:${id}`
            )}, ${moduleExportExpressionWrapper(
              finalOption.globalsPkg2VarName[id]
            )});`
          ),
          "\n" + finalJsCode
        ].filter((s) => s).join("\n");
        if (finalOption.hasDynamicImport) {
          if (typeof finalOption.systemjs == "function") {
            finalOption.collectRequireUrls.push(
              ...getSystemjsRequireUrls(finalOption.systemjs)
            );
          } else {
            finalJsCode = (await systemjsTexts.value).join("\n") + "\n" + finalJsCode;
          }
        }
      } else {
        Object.entries(finalBundle).forEach(([k, chunk]) => {
          if (chunk.type == "chunk" && chunk.isEntry) {
            finalJsCode = chunk.code;
          }
        });
      }
      const bannerCode = [
        await finalMonkeyOptionToComment(finalOption),
        finalOption.injectCssCode
      ].filter((s) => s).map((s) => s + `

`).join(``);
      finalJsCode = bannerCode + finalJsCode;
      this.emitFile({
        type: "asset",
        fileName: finalOption.build.fileName,
        source: finalJsCode
      });
      const { metaFileName, fileName } = finalOption.build;
      if (metaFileName) {
        this.emitFile({
          type: "asset",
          fileName: metaFileName(fileName),
          source: await finalMonkeyOptionToComment(finalOption)
        });
      }
    }
  };
};

// src/node/plugins/perview.ts
var import_promises4 = __toESM(require("fs/promises"), 1);
var import_node_path4 = __toESM(require("path"), 1);
var import_vite9 = require("vite");
async function* walk(dirPath) {
  const pathnameList = (await import_promises4.default.readdir(dirPath)).map(
    (s) => import_node_path4.default.join(dirPath, s)
  );
  while (pathnameList.length > 0) {
    const pathname = pathnameList.pop();
    const state = await import_promises4.default.lstat(pathname);
    if (state.isFile()) {
      yield pathname;
    } else if (state.isDirectory()) {
      pathnameList.push(
        ...(await import_promises4.default.readdir(pathname)).map((s) => import_node_path4.default.join(pathname, s))
      );
    }
  }
}
var perviewPlugin = (finalOption) => {
  let viteConfig;
  return {
    name: "monkey:perview",
    apply: "serve",
    configResolved(config) {
      viteConfig = config;
    },
    async configurePreviewServer(server) {
      server.middlewares.use(async (req, res, next) => {
        if (["/", "/index.html"].includes((req.url ?? "").split("?")[0])) {
          const distDirPath = import_node_path4.default.join(process.cwd(), viteConfig.build.outDir);
          for await (const pathname of walk(distDirPath)) {
            if (pathname.endsWith(".user.js")) {
              const fileName = (0, import_vite9.normalizePath)(
                import_node_path4.default.relative(distDirPath, pathname)
              );
              Object.entries({
                "content-type": "text/html; charset=utf-8"
              }).forEach(([k, v]) => {
                res.setHeader(k, String(v));
              });
              res.end(
                `<script type="module" data-source="vite-plugin-monkey">${fn2string(
                  redirectFn,
                  "/" + fileName
                )}</script>`
              );
              return;
            }
          }
        }
        next();
      });
    }
  };
};

// src/node/plugins/collectCss.ts
var import_vite10 = require("vite");
var collectCssPlugin = (finalOption) => {
  let viteConfig;
  return {
    name: "monkey:collectCss",
    apply: "build",
    enforce: "post",
    configResolved(config) {
      viteConfig = config;
    },
    async generateBundle(_, esmBundle) {
      const cssBundleList = Object.entries(esmBundle).filter(
        ([k]) => k.endsWith(".css")
      );
      const cssList = [];
      cssBundleList.forEach(([k, v]) => {
        if (v.type == "asset") {
          cssList.push(v.source.toString());
          delete esmBundle[k];
        }
      });
      if (cssList.length > 0) {
        let css = cssList.join("");
        if (!viteConfig.build.minify && finalOption.build.minifyCss) {
          const { cssTarget, target } = viteConfig.build;
          const finalCssTarget = getFinalTarget(cssTarget || target || []);
          css = (await (0, import_vite10.transformWithEsbuild)(css, "any_name.css", {
            sourcemap: false,
            legalComments: "none",
            minify: true,
            target: finalCssTarget
          })).code.trimEnd();
        }
        finalOption.injectCssCode = await miniCode(
          fn2string(cssInjectFn, " " + css + " "),
          // use \x20 to compat unocss, see https://github.com/lisonge/vite-plugin-monkey/issues/45
          // TODO check the order of plugin-monkey is last in vite plugin list, if not, logger warn message
          "js"
        );
      }
    }
  };
};

// src/node/plugins/redirectClient.ts
var redirectClientPlugin = (finalOption) => {
  return {
    name: "monkey:redirectClient",
    enforce: "pre",
    apply: "build",
    resolveId(source, importer, options) {
      if (source == "vite-plugin-monkey/dist/client") {
        return this.resolve(
          "vite-plugin-monkey/dist/native",
          importer,
          options
        );
      }
    }
  };
};

// src/node/plugins/inlinesAsset.ts
var import_promises5 = __toESM(require("fs/promises"), 1);
var inlinesAssetPlugin = (finalOption) => {
  let viteConfig;
  return {
    name: "monkey:inlinesAsset",
    enforce: "post",
    apply: "build",
    async configResolved(resolvedConfig) {
      viteConfig = resolvedConfig;
    },
    async transform(code, id) {
      if (viteConfig.assetsInclude(id) && [`.svg`, `.svg?inline`, `.svg?url`].some((s) => id.endsWith(s)) && code.includes(`__VITE_ASSET__`)) {
        const base64Text = (await import_promises5.default.readFile(id.split("?")[0])).toString(
          "base64"
        );
        return `export default ${JSON.stringify(
          `data:image/svg+xml;base64,` + base64Text
        )}`;
      }
    },
    generateBundle(opts, bundle) {
      for (const key in bundle) {
        if ([`.svg`].some((s) => key.endsWith(s))) {
          delete bundle[key];
        }
      }
    }
  };
};

// src/node/plugins/index.ts
var monkeyPluginList = [
  // only serve
  virtualHtmlPlugin,
  fixViteAssetPlugin,
  fixViteClientPlugin,
  serverPlugin,
  // only build pre
  redirectClientPlugin,
  externalLoaderPlugin,
  externalResourcePlugin,
  externalGlobalsPlugin,
  // only build post
  autoGrantPlugin,
  inlinesAssetPlugin,
  collectCssPlugin,
  // only build, final build
  finalBundlePlugin,
  // only preview
  perviewPlugin
];
var plugins_default = monkeyPluginList;

// src/node/index.ts
var node_default = (pluginOption) => {
  const finalPluginOption = resolvedOption(pluginOption);
  const monkeyPlugin = {
    name: "monkey:entry",
    async config(userConfig, { command }) {
      var _a, _b;
      const isServe = command == "serve";
      return {
        resolve: {
          alias: {
            [finalPluginOption.clientAlias]: "vite-plugin-monkey/dist/client"
          }
        },
        define: {
          "process.env.NODE_ENV": ((_a = userConfig.define) == null ? void 0 : _a["process.env.NODE_ENV"]) ?? JSON.stringify(
            userConfig.mode ?? (isServe ? "development" : "production")
          )
        },
        esbuild: {
          supported: {
            "top-level-await": true
          }
        },
        build: {
          assetsInlineLimit: Number.MAX_SAFE_INTEGER,
          chunkSizeWarningLimit: Number.MAX_SAFE_INTEGER,
          modulePreload: false,
          assetsDir: "./",
          cssCodeSplit: false,
          minify: ((_b = userConfig.build) == null ? void 0 : _b.minify) ?? false,
          rollupOptions: {
            // serve pre-bundling need
            input: finalPluginOption.entry
          },
          sourcemap: false
          // TODO
          // sourcemap: sourcemap,
        }
      };
    }
  };
  return [monkeyPlugin, ...plugins_default.map((m) => m(finalPluginOption))];
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  cdn,
  util
});
//# sourceMappingURL=index.cjs.map